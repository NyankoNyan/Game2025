# Алгоритм генерации городского района на основе динамической сетки

## Глосарий
- Сетка — двухмерный грид, каждая ячейка которого зовётся блоком
- Активная зона — пустая зона вокруг всей совокупности комнат 
- Комната - блок или совокупность блоков грида, которые размещаются на сетке

## Базовые операции
- Инициализировать сетку {размер_активной_зоны, размерность_грида}
- Проверить блок в сетке для комнаты {все_комнаты_строки, все_комнаты_столбца, параметры_комнаты} - проверяет можно ли разместить комнату в этом блоке. 
Для этого проверяется, подходит ли комната по размерам к другим комнатам в столбце и строке, можно ли изменить размер строки или столбца, можно ли объединить комнату с соседней ячейкой, нет ли в определённом радиусе других комнат.
- Проверить область для комнаты {предполагаемая_зона_размещения, параметры_комнаты} -> {список_изменений} - проверяет блоки прямоугольной области начиная с её центра на возможность размещения комнаты

## Параметры
- размерность_грида - максимальный и минимальный размер ячейки сетки по каждой из осей

## Алгоритм
1. На вход алгоритма подаётся граф связности комнат и параметры генерации.
1. Устанавливается начальный узел комнаты в нулевой блок грида. Дочерние узлы будем проходить как дерево в ширину.
1. Для каждого следующего узла.
	1. Устанавливаем область, где может находиться комната. Для этого берём сторону и дальность от родительской комнаты.
	1. Проверям область на возможность размещения комнаты и пути к ней (может потребоваться дорога определённой ширины или строка определённой ширины).
	1. Если разместить невозможно, смотрим на стратегию при ошибке размещения.
		1. Если комната низкоприоритетная, добавляем значение ошибки генерации от комнаты к ошибке уровня и отбрасываем.
		1. Если комната важная, пробуем расширить дальность установки, последовательно до значения запредельной дальности.
			1. Если комнату всё ещё не поставили, добавляем _ошибку_ генерации и отбрасываем.
			1. Если поставили, добавляем специальный флаг сложного пути и _погрешность_ генерации.
		1. Если комната обязательная, то расширяем дальность установки как в пункте выше.
			1. Но если поставить не можем, то падаем с ошибкой генерации.
	1. Добавляем информацию о связи между комнатами (с флагом сложного пути при необходимости).
	1. Добавляем инфу о комнатах.
	1. Замораживаем пути. Для этого для каждой дороги между двумя перекрёстками нужно определить свойства. Свойства зависят от способа построения пути.
		1. Прямой путь (дорога). Находим все возможные прямые дороги между двумя комнатами, и выбираем не меньше одной. Закрепляем размеры дорог и сами дороги. Может быть углом или зигзагом, если разрешено.
		1. Прямой путь (блоки). Находим одну линию незанятых блоков, подходящих по размеру. Закрепляем блоки в этой линии и параллельные ей примыкающие дороги. Может быть углом или зигзагом, если разрешено.
		1. Путь руин.
			1. Протагиваем между комнатами линию определённой толщины.
			1. Смотрим что попавшие в неё блоки не заняты.
			1. Помечаем блоки как руины.
			1. Не закрепляем ничего.
		1. Путь лабиринта. 
			1. Протягиваем между двумя комнатами линию определённой толщины. 
			1. Находим все перекрёстки и строим граф дорог.
			1. Убираем из него все неподходящие закреплённые дороги (делаем непроходимыми).
			1. Убираем случайные перекрёстки (делаем непроходимыми), пока граф сохраняет проходимость. 
			1. Убираем мёртвые перекрёстки.
			1. Допустимо, что в каких-то местах дорога раздваивается.
1. Ищем комнаты-соседи среди тех, где нет путей и соединяем их путями, если разрешено и если можем.
1. Находим свободные строки и столбцы и размещаем на них объекты ландшафта (реки, стены).
1. Случайным образом наращиваем блоки, где можем. Удаляем дороги между ними.
1. Строим карту тепла от размещенных блоков и дорог. При большом удалении блок становится неразрушаемым, а дороги между такими блоками непроходимыми с неразрушаемыми баррикадами.


### Примечание
Поскольку требуется практически для каждого действия выполнять некую случайную операцию, предлагается использовать деление по модулю достаточно большого простого числа. На крайний случай можно использовать n^2^+1, но можно взять какие-то предгены.

## Архитектура
Важно, чтобы каждый шаг генерации был отдельной единицей со своим результатом. В этом случае можно будет выполнять отладку генерации в графическом режиме пошагово.